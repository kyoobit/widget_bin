alias oneliners='cat $HOME/repos/widget_bin/oneliners.txt';

## Age - a file encryption tool
age-keygen -o key.txt
tar cz data | age -r $(cat key.txt) > data.tar.gz.age
age --decryptt -i key.txt data.tar.gz.age > data.tar.gz

apropos <WORD>

## BASH
#!/bin/bash
#!/usr/bin/env bash
$ foo=1:2:3:4:5; echo ${foo##*:} => 5
$ foo=1:2:3:4:5; echo ${foo#*:}  => 2:3:4:5
$ foo=1:2:3:4:5; echo ${foo%%:*} => 1
$ foo=1:2:3:4:5; echo ${foo%:*}  => 1:2:3:4
$ foo=""; echo ${foo:-bar}; foo="foo"; echo ${foo:-bar}; foo=""; echo ${foo:-bar};
$ foo=""; echo ${foo}; echo ${foo:=bar}; echo ${foo};
$ foo=""; bar="bar"; echo ${foo:+bar};
$ foo=""; echo ${foo:?"error message"}; echo ${foo:?};
$ foo=""; echo ${foo:?"error message"}; => -bash: foo: error message
$ foo=""; echo ${foo:?}; => -bash: foo: parameter null or not set
$ foo=""; echo ${foo}; foo=${1-false}; echo ${foo}; if [[ ${foo} == false ]]; then echo "hit"; else echo "miss"; fi;
$ echo "addr=10."$((RANDOM%255)).$((RANDOM%255)).$((RANDOM%255))
for ((n=14; n<=17; n++)); do echo ${n}; done

for i in $(cat list); do something; read PAUSE; done
for i in $(cat list); do something | shuf | head -n 1; done

while read -r line; do
    echo "$line" | awk '{print $2}'
done < <( ... )

cat << EOF > some-file.txt
Multi-line blob of text
EOF

crontab (but you know you should use systemd timers instead)
# .------------- minute (0 - 59) */10 == every ten minutes
# |  .---------- hour (0 - 23)
# |  |  .------- day of month (1 - 31)
# |  |  |  .---- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .- day of week (0 - 6) (Sunday=0 or 7) 
# |  |  |  |  |  -or- sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |  TEST: env > ~/cronenv; env - `cat ~/cronenv` /bin/sh
# *  *  *  *  *  <command to be executed> 2>&1 >> <always log>

echo "send a message" | wall

systemctl status firewalld
sudo firewall-cmd --get-zones
sudo firewall-cmd --get-active-zones
sudo firewall-cmd --set-default-zone=public
sudo firewall-cmd --list-all
sudo firewall-cmd --reload

sudo fdisk -l
sudo fdisk /dev/sda
n p
w
sudo wipefs --all /dev/sda --force
sudo mkfs.xfs -f /dev/sda1

find /opt/homebrew/share -perm -g+w

## Gherkin issue template
**As a** [role]
**I need** [function]
**So that** [benefit]

### Details and Assumptions
* [document what you know]

### Acceptance Criteria

```gherkin
Given [some context]
When [certain action is taken]
Then [the outcome of action is observed]
```

## Git branch and merge cycle
git clone <url>
git checkout main
git pull
git checkout -b <branch name>
  feature/<feature-id>/<description>
  fix/<issue-id>/<description>
  release/<release-string>
git merge main
  ...work, work, whoops ...
git stash (stash changes)
git reset --soft (keeps local changes)
git reset --hard (destructive to last commit)
git checkout . (????)
  ...work, work, work ...
git status
git add <files>
git commit -m '<a useful message>'
git push -u origin <branch name>
  ...follow open pull request instructions...
git checkout main
git pull
git branch -d <branch name>
git stash pop (restore stashed changes)
  ...fork! rollback
git checkout -b <revert_something>
git log -n 3
git revert --no-commit --mainline 1 HEAD~1
git revert --continue
git diff HEAD..origin/main
git push

grep --line-buffered --color=always

sudo ip link add bridge0 type bridge
sudo ip link set <INTERFACE> master bridge0
sudo ip address add <ADDRESS>/24 dev bridge0
sudo ip link set dev bridge0
sudo ip link set dev bridge0 up
sudo ip route add <DST ADDRESS> via <GATEWAY> dev <INTERFACE>
sudo ip link set <INTERFACE> down

sudo iptables -n -L -v
sudo vi /etc/sysconfig/iptables
sudo /etc/init.d/iptables reload

## JunOS Rooter Router
help topic ?
help reference ?
help apropos ?
help syslog <TAG>
show chassis fabric summary
show chassis environment
show chassis power
show chassis fan
show system storage
show chassis alarms
show system alarms
show system core-dumps
show system uptime
show system commit
show log messages | last 10
show | compare rollback 1
show interfaces * terse | except \.
show interfaces <PATTERN> | display set
show interfaces <INTERFACE> statistics
monitor interface <INTERFACE>
monitor traffic matching (src || dst <ADDRESS>)&&tcp&&port <PORT> write-file file.pcap count 150
ping <ADDRESS> interval 0.1 size 1472 do-not-fragment count 2000
traceroute <ADDRESS> bypass-routing inet6 interface <INTERFACE>
disable interface <INTERFACE>
set interface <INTERFACE> [<unit#>] disable
delete interface <INTERFACE> [<unit#>] disable
enable interface <INTERFACE>
request system storage cleanup dry-run
request system reboot
request system power-off

lsblk
sudo pvdisplay
sudo vgdisplay
sudo lvdisplay
sudo lvresize --resizefs --size +<PE SIZE FREE - 0.1>G <LV PATH> --test
lsblk --output MOUNTPOINT,UUID
sudo vi /etc/fstab
sudo systemctl daemon-reload

## Lowercase
tr '[:upper:]' '[:lower:]'
awk '{print tolower($0)}'

ping -q -s 1472 -M do -c 10 <ADDRESS>
sudo -iu root ping -q -s 1472 -M do -i .01 -c 2000 <ADDRESS>
ping: -s size MTU minus 28 for IPv4 or MTU minus 48 for IPv6
ping: -M do = prohibit fragmentation
nping --tcp-connect --dest-port 80 --count 100 --delay 100ms <ADDRESS>

## Find a process by port using nestat|ss and ps
netstat -nP -iTCP
netstat -anv | grep <PORT>
ps -Ao user,pid,command | grep -v grep | grep <PID>

nftables - A modern Linux kernel packet classification framework - https://wiki.nftables.org/
sudo nft list tables [<FAMILY:ip|arp|ip6|bridge|inet|netdev>]
sudo nft list table <TABLE>
sudo nft -n -a list table <TABLE>
nft list chain <TABLE> <CHAIN>
sudo nft 'add chain [<FAMILY>] <TABLE NAME> <CHAIN NAME> \
  { type <TYPE> hook <HOOK> [device <DEVICE>] priority <PRIORITY>; [policy <POLICY>;] [comment <COMMENT>;] }
sudo nft 'add table ip filter'
sudo nft 'add chain ip filter input { type filter hook input priority 0; }'
sudo nft 'add chain ip filter output { type filter hook output priority 0; }'
sudo nft 'add rule <TABLE> <CHAIN> <FAMILY> ...'
sudo nft 'add rule filter output ip daddr 4.3.2.1 counter'
sudo nft 'insert rule <TABLE> <CHAIN> position <INT> ...'
sudo nft 'replace rule <TABLE> <CHAIN> handle <INT> ...'
sudo nft 'delete rule <TABLE> <CHAIN> handle <INT>'

nmcli connection show
nmcli device show <INTERFACE>
sudo nmcli connection add con-name vbr1s0 ifname vbr1s0 type bridge stp off
sudo nmcli connection modify vbr1s0 ipv4.addresses '<ADDRESS>/24'
sudo nmcli connection modify vbr1s0 ipv4.gateway <ADDRESS>
sudo nmcli connection modify vbr1s0 ipv4.dns <ADDRESS>
sudo nmcli connection up vbr1s0

sudo vi /etc/sysctl.d/50-enable-forwarding.conf
sysctl net.ipv4.ip_forward
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
sysctl net.ipv6.conf.default.forwarding
echo 1 | sudo tee /proc/sys/net/ipv6/conf/default/forwarding
# Enable forwarding for dual stack
net.ipv4.ip_forward=1
net.ipv6.conf.all.forwarding=1

## Check for the need to reboot to finalize a security or kernel update:
if [[ -s /var/run/reboot-required ]]; then cat /var/run/reboot-required; else echo "System reboot NOT required"; fi

## Saltiness
sudo salt '<pattern>|*' <function>.<action> <arguments> --out json

sudo salt-run manage.status                     # List minions up/down (manage.up|alived|down)
sudo salt '*' --preview-target
sudo salt '*' test.ping|version                 # Ping (not ICMP) minions or show salt version
sudo salt --pcre 'node[1-3]-(dev|qa)' test.ping # Match a PCRE pattern instead shell glob
sudo salt --list 'node1,node3,node5' test.ping  # Match a comma-separated list of minions
sudo salt --pillar 'role:prod*'                 # Match a pillar value to identify minions
sudo salt --ipcidr '192.168.123.0/24'           # Match a CIRD or IP address

sudo salt '*' grains --doc
sudo salt '*' grains.ls                         # List grains (minion system properties)
sudo salt --grain os:Fedora grains.items        # Match all Fedora minions and list grain values (system properties)
sudo salt foo01 grains.setval deployment bar    # Set the grain deployment to a value (/etc/salt/grains)
sudo salt foo01 grains.setval role ['bar', ...] # Set the grain role to a list of values (/etc/salt/grains)

sudo salt '*' cp --doc
sudo salt '*' cp.get_file salt://nginx/nginx.conf /etc/nginx/nginx.conf     # Copy nginx.conf to all web* matching
sudo salt '*' cp.get_file_str /etc/nginx/nginx.conf                         # Displays the content of nginx.conf
sudo salt '*' cp.get_template salt://nginx/nginx.conf /etc/nginx/nginx.conf # Similar to get_file but execute the templating system
sudo salt '*' cp.get_dir salt://etc/nginx/ /etc/nginx/                      # Copy a directory of files from master to minion
sudo salt '*' nginx.signal reload                                           # Reload NGINX configuration sending a SIGNHUP

sar -pd -n DEV,EDEV -u ALL 5 24 (disk,network,cpu activity every 5 seconds for 24 measurements)
sar -dp (just disk activity)
iostat -dmx (like sar -dp)

ssh -L <PORT>:localhost:<PORT> -N -l <USER> <HOST|ADDRESS>

## tar pipe:
[ -d ${SOURCE} -a ! ${SOURCE} -ef ${TARGET} ]; tar cf - ${SOURCE} | (cd ${TARGET}; tar xvf -)

<some command> | tee /dev/tty | <some command>

sudo -iu root tcpdump -nnvvS net <ADDRESS> and src not <ADDRESS> and not <ADDRESS>
sudo -iu root tcpdump -s 1600 -i any -nn tcp port <PORT> and host <ADDRESS> -Z <USER> -w ~<USER>/$(hostname)-$(date '+%s').pcap

## Tmux Terminal Multiplexer
┌──────────────────────┐
│┌────────────────────┐│
││┌────────┐┌────────┐││
│││ SHELL$ ││ SHELL$ │││
││└─ PANE ─┘└─ PANE ─┘││
│└─ WINDOW(S) ────────┘│
└─ SESSION(S) ─────────┘
tmux new-session -s <NAME>                <--- start a new session
tmux new -s <NAME>                        <--- start a new session
tmux new -s <NAME> -n <NAME>              <--- start a new session named <NAME>
tmux new -s <NAME> -d                     <--- start a new session detached
tmux new -s <NAME> -d 'command(s) to run' <--- start a new session detached, running a command, session exits when command exits
tmux new -s 'tri-panel' \; split-window -h -p 66 \; split-window -h \;
tmux list-sessions
tmux ls
tmux attach                               <--- attach the first session
tmux attach -t <NAME>                     <--- attach a session by name
tmux kill-session -t <NAME>
Prefix ? <--- list predefined keybindings and associated commands
Prefix $ <--- rename session
Prefix d <--- detach session
Prefix c <--- create a new window
Prefix , <--- rename window
Prefix w <--- list of windows with a preview
Prefix f <--- find a window by name
Prefix <ARROW>  <--- move to window pane in direction of <ARROW>
Prefix ! <--- create a window from the window active pane
Prefix z <--- enter/exit full window zoom of a window pane
Prefix : <--- enter command mode
even-horizontal      <--- stack all panes horizontally, left to right
even-vertical        <--- stack all panes vertically, top to bottom
main-horizontal      <--- create one larger pane on the top and smaller panes underneath
main-vertical        <--- creates one large pane on the left side of the screen, stacks the rest vertically on the right
new-window -n <NAME> <--- new window with name <NAME>
new-window -n <NAME> "command(s)"   <--- new window with name <NAME> running "command(s)", window closes when command exits
set-window-option synchronize-panes on <--- synchronize command entry on multiple panes
tmux send-keys -t [session]:[window].[pane] 'command(s) to run' C-m

## top one shot sorted by RES memory
top -b -n 1 -o +RES -E m -e m

## Configure vi to search .bash_history: ESC + /
echo "set -o vi" >> ~/.bash_profile && source ~/.bash_profile

sudo usermod --groups <GROUP> --append <USER>

watch -n <SECONDS> <COMMAND>
